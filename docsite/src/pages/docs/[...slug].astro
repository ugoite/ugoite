---
import { promises as fs } from "node:fs";
import path from "node:path";
import { Marked } from "marked";
import YAML from "yaml";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { titleFromSegment } from "../../lib/navigation";

type TocItem = {
  id: string;
  title: string;
};

function escapeHtml(raw: string): string {
  return raw
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function escapeAttribute(raw: string): string {
  return escapeHtml(raw).replaceAll("`", "&#96;");
}

function sanitizeUrl(raw: string | null | undefined): string | null {
  if (!raw) return null;
  const trimmed = raw.trim();
  if (trimmed.length === 0) return null;

  if (
    trimmed.startsWith("/") ||
    trimmed.startsWith("./") ||
    trimmed.startsWith("../") ||
    trimmed.startsWith("#")
  ) {
    return trimmed;
  }

  try {
    const parsed = new URL(trimmed, "https://example.local");
    if (parsed.protocol === "http:" || parsed.protocol === "https:") {
      return trimmed;
    }
  } catch {
    return null;
  }

  return null;
}

const safeMarked = new Marked({
  gfm: true,
});

const toc: TocItem[] = [];

safeMarked.use({
  renderer: {
    html(token) {
      return escapeHtml(token.text);
    },
    link({ href, title, text }) {
      const safeHref = sanitizeUrl(href);
      const safeText = escapeHtml(text ?? href ?? "link");
      if (!safeHref) {
        return safeText;
      }

      const titleAttr = title ? ` title="${escapeAttribute(title)}"` : "";
      return `<a href="${escapeAttribute(safeHref)}"${titleAttr} rel="noopener noreferrer">${safeText}</a>`;
    },
    image({ href, title, text }) {
      const safeSrc = sanitizeUrl(href);
      if (!safeSrc) {
        return "";
      }

      const safeAlt = escapeAttribute(text ?? "");
      const titleAttr = title ? ` title="${escapeAttribute(title)}"` : "";
      return `<img src="${escapeAttribute(safeSrc)}" alt="${safeAlt}"${titleAttr} loading="lazy" decoding="async" />`;
    },
    heading({ tokens, depth }) {
      const text = this.parser.parseInline(tokens);
      const raw = tokens.map((token) => token.raw).join(" ").trim();
      const id = raw
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, "")
        .trim()
        .replace(/\s+/g, "-");
      if (depth <= 3 && raw.length > 0 && id.length > 0) {
        toc.push({ id, title: raw });
      }
      return `<h${depth} id="${id}">${text}</h${depth}>`;
    },
  },
});

export async function getStaticPaths() {
  const docsRoot = path.resolve(process.cwd(), "../docs");
  const walkDocFiles = async (dir: string): Promise<string[]> => {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) return await walkDocFiles(fullPath);
        if (entry.isFile() && /\.(md|ya?ml)$/.test(entry.name)) return [fullPath];
        return [];
      })
    );
    return files.flat();
  };

  const docFiles = await walkDocFiles(docsRoot);
  return docFiles.map((file) => {
    const relative = path.relative(docsRoot, file).replace(/\\/g, "/");
    const slug = relative.replace(/\.(md|ya?ml)$/, "");
    return { params: { slug } };
  });
}

const docsRoot = path.resolve(process.cwd(), "../docs");
const slugPath = String(Astro.params.slug || "").replace(/^\/+/, "");
const candidates = [`${slugPath}.md`, `${slugPath}.yaml`, `${slugPath}.yml`];

let relativePath: string | null = null;
let fullPath: string | null = null;
for (const candidate of candidates) {
  const candidatePath = path.join(docsRoot, candidate);
  try {
    await fs.access(candidatePath);
    relativePath = candidate;
    fullPath = candidatePath;
    break;
  } catch {
    continue;
  }
}

if (!fullPath || !relativePath) {
  throw new Error(`Doc source not found for slug: ${slugPath}`);
}

const source = await fs.readFile(fullPath, "utf-8");
const isYaml = /\.(ya?ml)$/.test(relativePath);

const html = isYaml
  ? renderYamlAsHtml(YAML.parse(source) as unknown)
  : (safeMarked.parse(source) as string);

const parts = slugPath.split("/").filter(Boolean);
const breadcrumbs = parts.map((part, index) => ({
  label: titleFromSegment(part),
  href: `/docs/${parts.slice(0, index + 1).join("/")}`,
}));

const related = await getRelatedLinks(relativePath);

function renderCellValue(cellValue: unknown, key: string): string {
  if (Array.isArray(cellValue)) {
    if (cellValue.length === 0) return `<td style="font-size:0.8125rem;color:var(--doc-muted);">â€”</td>`;
    // Show simple arrays as pills
    const allSimple = cellValue.every((v) => typeof v === "string" || typeof v === "number");
    if (allSimple) {
      return `<td><div style="display:flex;flex-wrap:wrap;gap:0.25rem;">${(cellValue as unknown[]).map((v) => `<span class="doc-pill doc-pill-outline" style="font-size:0.625rem;">${escapeHtml(String(v))}</span>`).join("")}</div></td>`;
    }
    return `<td style="font-size:0.8125rem;color:var(--doc-muted);">${cellValue.length} items</td>`;
  }
  if (cellValue && typeof cellValue === "object") {
    const obj = cellValue as Record<string, unknown>;
    // Show a compact summary of nested objects
    const summaryKey = ["function", "command", "path", "file", "name", "title"].find((k) => k in obj);
    if (summaryKey) {
      const summaryVal = escapeHtml(String(obj[summaryKey]));
      const extraCount = Object.keys(obj).length - 1;
      return `<td style="font-size:0.75rem;"><code style="background:var(--doc-bg-subtle);padding:0.125rem 0.25rem;border-radius:var(--doc-radius-sm);word-break:break-all;">${summaryVal}</code>${extraCount > 0 ? `<span style="font-size:0.625rem;color:var(--doc-muted);margin-left:0.25rem;">+${extraCount}</span>` : ""}</td>`;
    }
    return `<td style="font-size:0.8125rem;color:var(--doc-muted);">${Object.keys(obj).length} fields</td>`;
  }
  if (key === "id") {
    return `<td><code style="font-size:0.75rem;background:var(--doc-bg-subtle);padding:0.125rem 0.375rem;border-radius:var(--doc-radius-sm);white-space:nowrap;">${escapeHtml(String(cellValue ?? ""))}</code></td>`;
  }
  if (key === "priority" || key === "status") {
    const v = String(cellValue ?? "");
    const colorMap: Record<string, string> = { high: "#dc2626", medium: "#d97706", low: "#16a34a", implemented: "#16a34a", planned: "#2563eb", draft: "#6b7280" };
    const clr = colorMap[v.toLowerCase()] ?? "var(--doc-fg)";
    return `<td><span style="font-size:0.6875rem;font-weight:600;color:${clr};text-transform:uppercase;letter-spacing:0.05em;">${escapeHtml(v)}</span></td>`;
  }
  return `<td style="font-size:0.8125rem;">${escapeHtml(String(cellValue ?? ""))}</td>`;
}

function renderYamlAsHtml(value: unknown, depth = 0): string {
  if (Array.isArray(value)) {
    const allObjects = value.every((item) => item && typeof item === "object" && !Array.isArray(item));
    const hasIdTitle = allObjects && value.every((item) => {
      const obj = item as Record<string, unknown>;
      return "id" in obj || "title" in obj || "name" in obj;
    });

    if (hasIdTitle && value.length > 0) {
      // Detect shared fields (identical across all items) vs varying fields
      const allKeys = [...new Set(value.flatMap((item) => Object.keys(item as Record<string, unknown>)))];
      const sharedKeys: string[] = [];
      const varyingKeys: string[] = [];

      for (const key of allKeys) {
        const values = value.map((item) => JSON.stringify((item as Record<string, unknown>)[key]));
        const allSame = values.every((v) => v === values[0]);
        if (allSame && value.length > 1) {
          sharedKeys.push(key);
        } else {
          varyingKeys.push(key);
        }
      }

      // If we have shared keys, show them once at the top then render individual items
      if (sharedKeys.length > 0 && varyingKeys.length > 3) {
        const shared = value[0] as Record<string, unknown>;
        const sharedHtml = `<div style="background:var(--doc-bg-subtle);border-radius:var(--doc-radius-md);padding:0.75rem 1rem;margin-bottom:0.75rem;"><div style="display:flex;flex-wrap:wrap;gap:0.75rem;">${sharedKeys
          .map((k) => {
            const v = shared[k];
            if (Array.isArray(v)) {
              return `<div><span style="font-size:0.625rem;font-weight:600;text-transform:uppercase;letter-spacing:0.05em;color:var(--doc-muted);">${escapeHtml(k)}</span><div style="display:flex;flex-wrap:wrap;gap:0.25rem;margin-top:0.25rem;">${(v as unknown[]).map((item) => `<span class="doc-pill doc-pill-outline" style="font-size:0.625rem;">${escapeHtml(String(item))}</span>`).join("")}</div></div>`;
            }
            return `<div><span style="font-size:0.625rem;font-weight:600;text-transform:uppercase;letter-spacing:0.05em;color:var(--doc-muted);">${escapeHtml(k)}</span><div style="font-size:0.8125rem;margin-top:0.125rem;">${escapeHtml(String(v))}</div></div>`;
          })
          .join("")}</div></div>`;

        // Render varying fields as individual cards
        const itemsHtml = value.map((item) => {
          const obj = item as Record<string, unknown>;
          const idVal = String(obj["id"] ?? obj["name"] ?? "");
          const titleVal = obj["title"] ? String(obj["title"]) : "";
          const descVal = obj["description"] ? String(obj["description"]) : "";
          const priorityVal = obj["priority"] ? String(obj["priority"]) : "";
          const statusVal = obj["status"] ? String(obj["status"]) : "";

          // Build header with id + status badges
          let headerRight = "";
          if (priorityVal) {
            const colorMap: Record<string, string> = { high: "#dc2626", medium: "#d97706", low: "#16a34a" };
            headerRight += `<span class="doc-pill" style="font-size:0.5625rem;background:${colorMap[priorityVal.toLowerCase()] ?? "var(--doc-accent)"};color:white;">${escapeHtml(priorityVal)}</span>`;
          }
          if (statusVal) {
            const sColorMap: Record<string, string> = { implemented: "#16a34a", planned: "#2563eb", draft: "#6b7280" };
            headerRight += `<span class="doc-pill" style="font-size:0.5625rem;background:${sColorMap[statusVal.toLowerCase()] ?? "var(--doc-muted)"};color:white;margin-left:0.25rem;">${escapeHtml(statusVal)}</span>`;
          }

          const skipKeys = new Set(["id", "title", "description", "priority", "status", ...sharedKeys]);
          const remainingEntries = varyingKeys.filter((k) => !skipKeys.has(k));

          let detailHtml = "";
          for (const k of remainingEntries) {
            const v = obj[k];
            if (v === undefined || v === null) continue;
            detailHtml += `<div style="margin-top:0.5rem;"><span style="font-size:0.6875rem;font-weight:600;text-transform:uppercase;letter-spacing:0.05em;color:var(--doc-muted);">${escapeHtml(k)}</span><div style="font-size:0.8125rem;margin-top:0.125rem;">${renderYamlAsHtml(v, depth + 2)}</div></div>`;
          }

          return `<div style="border:var(--doc-border-width) solid var(--doc-border);border-radius:var(--doc-radius-md);padding:1rem;"><div style="display:flex;justify-content:space-between;align-items:flex-start;gap:0.5rem;flex-wrap:wrap;"><div><code style="font-size:0.75rem;background:var(--doc-bg-subtle);padding:0.125rem 0.375rem;border-radius:var(--doc-radius-sm);">${escapeHtml(idVal)}</code>${titleVal ? `<h3 style="font-size:0.9375rem;font-weight:700;margin:0.25rem 0 0;">${escapeHtml(titleVal)}</h3>` : ""}</div><div style="display:flex;gap:0.25rem;">${headerRight}</div></div>${descVal ? `<p style="font-size:0.8125rem;color:var(--doc-muted);margin:0.5rem 0 0;line-height:1.5;">${escapeHtml(descVal)}</p>` : ""}${detailHtml}</div>`;
        }).join("");

        return sharedHtml + `<div style="display:grid;gap:0.5rem;">${itemsHtml}</div>`;
      }

      // No significant shared keys: render as clean table
      // Prioritize important columns: id, title/name first, then description, then rest
      const priorityOrder = ["id", "name", "title", "summary", "description", "priority", "status"];
      const sortedKeys = [
        ...priorityOrder.filter((k) => varyingKeys.includes(k) || allKeys.includes(k)),
        ...allKeys.filter((k) => !priorityOrder.includes(k)),
      ].filter((k, i, arr) => arr.indexOf(k) === i);
      const displayKeys = sortedKeys.slice(0, 7); // Show up to 7 columns

      return `<div class="doc-table-wrap"><table class="doc-table"><thead><tr>${displayKeys
        .map((k) => `<th>${escapeHtml(k)}</th>`)
        .join("")}</tr></thead><tbody>${value
        .map((item) => {
          const obj = item as Record<string, unknown>;
          return `<tr>${displayKeys
            .map((k) => renderCellValue(obj[k], k))
            .join("")}</tr>`;
        })
        .join("")}</tbody></table></div>`;
    }

    // Simple list
    return `<ul style="list-style:disc;padding-left:1.25rem;margin:0.5rem 0;">${value
      .map((item) => `<li style="margin:0.25rem 0;">${renderYamlAsHtml(item, depth + 1)}</li>`)
      .join("")}</ul>`;
  }

  if (value && typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>);

    // Top-level: separate metadata from content
    if (depth === 0) {
      const metaKeys = ["category", "version", "language", "last_updated", "kind", "scope", "set_id", "source_file"];
      const metaEntries = entries.filter(([key]) => metaKeys.includes(key));
      const contentEntries = entries.filter(([key]) => !metaKeys.includes(key));

      let metaHtml = "";
      if (metaEntries.length > 0) {
        metaHtml = `<div class="doc-card" style="padding:0.875rem 1rem;margin-bottom:1rem;"><div style="display:flex;flex-wrap:wrap;gap:0.75rem;">${metaEntries
          .map(([key, v]) => `<div><span style="font-size:0.6875rem;font-weight:600;text-transform:uppercase;letter-spacing:0.05em;color:var(--doc-muted);">${escapeHtml(key)}</span><div style="font-size:0.8125rem;margin-top:0.125rem;">${escapeHtml(String(v))}</div></div>`)
          .join("")}</div></div>`;
      }

      const contentHtml = contentEntries
        .map(([key, v]) => `<div class="doc-card" style="padding:1.25rem;"><h2 style="font-size:1.125rem;font-weight:700;margin:0 0 0.75rem;">${escapeHtml(key)}</h2><div>${renderYamlAsHtml(v, depth + 1)}</div></div>`)
        .join("");

      return metaHtml + `<div style="display:grid;gap:0.75rem;">${contentHtml}</div>`;
    }

    // Nested objects render as compact key-value pairs
    const isSimple = entries.every(([, v]) => typeof v === "string" || typeof v === "number" || typeof v === "boolean");
    if (isSimple) {
      return `<div style="display:grid;grid-template-columns:auto 1fr;gap:0.25rem 0.75rem;font-size:0.8125rem;">${entries
        .map(([key, v]) => `<span style="font-weight:600;color:var(--doc-fg);">${escapeHtml(key)}</span><span style="color:var(--doc-muted);">${escapeHtml(String(v))}</span>`)
        .join("")}</div>`;
    }

    return `<div style="display:grid;gap:0.5rem;">${entries
      .map(([key, v]) => `<div style="border-left:2px solid var(--doc-border);padding-left:0.75rem;"><span style="font-size:0.8125rem;font-weight:600;">${escapeHtml(key)}</span><div style="font-size:0.8125rem;color:var(--doc-muted);margin-top:0.25rem;">${renderYamlAsHtml(v, depth + 1)}</div></div>`)
      .join("")}</div>`;
  }

  if (typeof value === "string") {
    return escapeHtml(value).replaceAll("\n", "<br />");
  }

  return escapeHtml(String(value));
}

async function getRelatedLinks(sourceFile: string): Promise<Array<{ href: string; label: string }>> {
  if (!sourceFile.startsWith("spec/")) {
    return [];
  }

  const catalogPath = path.join(docsRoot, "spec/specifications.yaml");
  try {
    const catalogRaw = await fs.readFile(catalogPath, "utf-8");
    const catalog = YAML.parse(catalogRaw) as Array<{
      source_file?: string;
      linked_policies?: string[];
      linked_requirements?: string[];
    }>;
    const relative = sourceFile.replace(/^spec\//, "");
    const hit = catalog.find((item) => item.source_file === relative);
    if (!hit) return [];

    const links: Array<{ href: string; label: string }> = [];
    for (const policy of hit.linked_policies ?? []) {
      links.push({ href: "/design/policies", label: `Policy ${policy}` });
    }
    for (const requirement of hit.linked_requirements ?? []) {
      links.push({ href: "/design/requirements", label: `Requirement ${requirement}` });
    }
    return links;
  } catch {
    return [];
  }
}
---

<BaseLayout title={`Docs: ${relativePath}`} description={`Repository source: /docs/${relativePath}`} toc={toc} related={related}>
  <div class="doc-card" style="padding: 0.75rem 1rem; margin-bottom: 1rem;">
    <nav style="font-size: 0.75rem; color: var(--doc-muted);">
      <a href="/">home</a>
      <span> / </span>
      <a href="/docs/spec/index">docs</a>
      {breadcrumbs.map((crumb) => (
        <>
          <span> / </span>
          <a href={crumb.href}>{crumb.label}</a>
        </>
      ))}
    </nav>
    <p style="font-size: 0.6875rem; color: var(--doc-muted); margin-top: 0.375rem;">
      Source: /docs/{relativePath}
    </p>
  </div>
  <article class="doc-prose">
    <Fragment set:html={html} />
  </article>
</BaseLayout>
