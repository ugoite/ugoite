---
import { promises as fs } from "node:fs";
import path from "node:path";
import { Marked } from "marked";
import YAML from "yaml";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { titleFromSegment } from "../../lib/navigation";

type TocItem = {
  id: string;
  title: string;
};

function escapeHtml(raw: string): string {
  return raw
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function escapeAttribute(raw: string): string {
  return escapeHtml(raw).replaceAll("`", "&#96;");
}

function sanitizeUrl(raw: string | null | undefined): string | null {
  if (!raw) return null;
  const trimmed = raw.trim();
  if (trimmed.length === 0) return null;

  if (
    trimmed.startsWith("/") ||
    trimmed.startsWith("./") ||
    trimmed.startsWith("../") ||
    trimmed.startsWith("#")
  ) {
    return trimmed;
  }

  try {
    const parsed = new URL(trimmed, "https://example.local");
    if (parsed.protocol === "http:" || parsed.protocol === "https:") {
      return trimmed;
    }
  } catch {
    return null;
  }

  return null;
}

const safeMarked = new Marked({
  gfm: true,
});

const toc: TocItem[] = [];

safeMarked.use({
  renderer: {
    html(token) {
      return escapeHtml(token.text);
    },
    link({ href, title, text }) {
      const safeHref = sanitizeUrl(href);
      const safeText = escapeHtml(text ?? href ?? "link");
      if (!safeHref) {
        return safeText;
      }

      const titleAttr = title ? ` title="${escapeAttribute(title)}"` : "";
      return `<a href="${escapeAttribute(safeHref)}"${titleAttr} rel="noopener noreferrer">${safeText}</a>`;
    },
    image({ href, title, text }) {
      const safeSrc = sanitizeUrl(href);
      if (!safeSrc) {
        return "";
      }

      const safeAlt = escapeAttribute(text ?? "");
      const titleAttr = title ? ` title="${escapeAttribute(title)}"` : "";
      return `<img src="${escapeAttribute(safeSrc)}" alt="${safeAlt}"${titleAttr} loading="lazy" decoding="async" />`;
    },
    heading({ tokens, depth }) {
      const text = this.parser.parseInline(tokens);
      const raw = tokens.map((token) => token.raw).join(" ").trim();
      const id = raw
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, "")
        .trim()
        .replace(/\s+/g, "-");
      if (depth <= 3 && raw.length > 0 && id.length > 0) {
        toc.push({ id, title: raw });
      }
      return `<h${depth} id="${id}">${text}</h${depth}>`;
    },
  },
});

export async function getStaticPaths() {
  const docsRoot = path.resolve(process.cwd(), "../docs");
  const walkDocFiles = async (dir: string): Promise<string[]> => {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) return await walkDocFiles(fullPath);
        if (entry.isFile() && /\.(md|ya?ml)$/.test(entry.name)) return [fullPath];
        return [];
      })
    );
    return files.flat();
  };

  const docFiles = await walkDocFiles(docsRoot);
  return docFiles.map((file) => {
    const relative = path.relative(docsRoot, file).replace(/\\/g, "/");
    const slug = relative.replace(/\.(md|ya?ml)$/, "");
    return { params: { slug } };
  });
}

const docsRoot = path.resolve(process.cwd(), "../docs");
const slugPath = String(Astro.params.slug || "").replace(/^\/+/, "");
const candidates = [`${slugPath}.md`, `${slugPath}.yaml`, `${slugPath}.yml`];

let relativePath: string | null = null;
let fullPath: string | null = null;
for (const candidate of candidates) {
  const candidatePath = path.join(docsRoot, candidate);
  try {
    await fs.access(candidatePath);
    relativePath = candidate;
    fullPath = candidatePath;
    break;
  } catch {
    continue;
  }
}

if (!fullPath || !relativePath) {
  throw new Error(`Doc source not found for slug: ${slugPath}`);
}

const source = await fs.readFile(fullPath, "utf-8");
const isYaml = /\.(ya?ml)$/.test(relativePath);

const html = isYaml
  ? renderYamlAsHtml(YAML.parse(source) as unknown)
  : (safeMarked.parse(source) as string);

const parts = slugPath.split("/").filter(Boolean);
const breadcrumbs = parts.map((part, index) => ({
  label: titleFromSegment(part),
  href: `/docs/${parts.slice(0, index + 1).join("/")}`,
}));

const related = await getRelatedLinks(relativePath);

function renderYamlAsHtml(value: unknown): string {
  if (Array.isArray(value)) {
    return `<ul>${value.map((item) => `<li>${renderYamlAsHtml(item)}</li>`).join("")}</ul>`;
  }

  if (value && typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>);
    return `<div class="space-y-3">${entries
      .map(
        ([key, entryValue]) =>
          `<section class="doc-card"><h3 class="text-base font-semibold">${escapeHtml(key)}</h3><div class="mt-2 text-sm" style="color: var(--doc-muted);">${renderYamlAsHtml(entryValue)}</div></section>`
      )
      .join("")}</div>`;
  }

  if (typeof value === "string") {
    return escapeHtml(value).replaceAll("\n", "<br />");
  }

  return escapeHtml(String(value));
}

async function getRelatedLinks(sourceFile: string): Promise<Array<{ href: string; label: string }>> {
  if (!sourceFile.startsWith("spec/")) {
    return [];
  }

  const catalogPath = path.join(docsRoot, "spec/specifications.yaml");
  try {
    const catalogRaw = await fs.readFile(catalogPath, "utf-8");
    const catalog = YAML.parse(catalogRaw) as Array<{
      source_file?: string;
      linked_policies?: string[];
      linked_requirements?: string[];
    }>;
    const relative = sourceFile.replace(/^spec\//, "");
    const hit = catalog.find((item) => item.source_file === relative);
    if (!hit) return [];

    const links: Array<{ href: string; label: string }> = [];
    for (const policy of hit.linked_policies ?? []) {
      links.push({ href: "/design/policies", label: `Policy ${policy}` });
    }
    for (const requirement of hit.linked_requirements ?? []) {
      links.push({ href: "/design/requirements", label: `Requirement ${requirement}` });
    }
    return links;
  } catch {
    return [];
  }
}
---

<BaseLayout title={`Docs: ${relativePath}`} description={`Repository source: /docs/${relativePath}`} toc={toc} related={related}>
  <section class="doc-card mb-4">
    <nav class="text-xs" style="color: var(--doc-muted);">
      <a href="/">home</a>
      <span> / </span>
      <a href="/docs/spec/index">docs</a>
      {breadcrumbs.map((crumb) => (
        <>
          <span> / </span>
          <a href={crumb.href}>{crumb.label}</a>
        </>
      ))}
    </nav>
    <p class="mt-2 text-xs" style="color: var(--doc-muted);"><span data-l10n-key="source_prefix">Source:</span> /docs/{relativePath}</p>
  </section>
  <article class="prose doc-prose max-w-none">
    <Fragment set:html={html} />
  </article>
</BaseLayout>
